{"pages":[],"posts":[{"title":"Dijkstra Algorithm","text":"다익스트라 알고리즘Dijkstra algorithm(이하 다익스트라 알고리즘)은 음의 가중치가 없는 그래프에서 한 노드에서 다른 모든 노드까지의 가장 짧은 거리를 구하는 알고리즘 중 하나이다. 선형구조로 구현된 다익스트라 알고리즘은 O(N^2)의 시간복잡도를 가지지만 힙을 이용해 구현하게 되면 O(NlogN)의 시간복잡도를 가지게 된다. 최단 거리를 구하는 경우는 현실에서도 흔하기 때문에 많이 사용되는 알고리즘이다. 구현123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104use std::collections::{HashMap, HashSet};use std::collections::BinaryHeap;use std::cmp::Ordering;use std::fmt;fn main() { let v1 = Vertex::new(\"v1\"); let v2 = Vertex::new(\"v2\"); let v3 = Vertex::new(\"v3\"); let v4 = Vertex::new(\"v4\"); let v5 = Vertex::new(\"v5\"); let mut vertex_graph = HashMap::new(); vertex_graph.insert(v1, vec![(v2, 10), (v4, 5)]); vertex_graph.insert(v2, vec![(v4, 2), (v3, 1)]); vertex_graph.insert(v3, vec![(v4, 4)]); vertex_graph.insert(v4, vec![(v2, 3), (v3, 9), (v5, 2)]); vertex_graph.insert(v5, vec![(v1, 7), (v3, 6)]); let distances = dijkstra(v1, &amp;vertex_graph); for (v, d) in &amp;distances { println!(\"{} {}\", v, d); }}fn dijkstra&lt;'a&gt;( s: Vertex&lt;'a&gt;, vl: &amp;HashMap&lt;Vertex&lt;'a&gt;, Vec&lt;(Vertex&lt;'a&gt;, usize)&gt;&gt;,) -&gt; HashMap&lt;Vertex&lt;'a&gt;, usize&gt; { let mut result = HashMap::new(); result.insert(s, 0); let mut to_visit = BinaryHeap::new(); to_visit.push(Visit { vertex: s, distance: 0, }); let mut visited = HashSet::new(); while let Some(Visit { vertex, distance }) = to_visit.pop() { if !visited.insert(vertex) { continue; } if let Some(other_vertexs) = vl.get(&amp;vertex) { for (other_vertex, cost) in other_vertexs { let accu_distance = distance + cost; let is_shorter = result.get(other_vertex) .map_or(true, |&amp;d| accu_distance &lt; d); if is_shorter { result.insert(*other_vertex, accu_distance); to_visit.push(Visit { vertex: *other_vertex, distance: accu_distance, }) } } } } result}#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]struct Vertex&lt;'a&gt; { name: &amp;'a str,}impl&lt;'a&gt; Vertex&lt;'a&gt; { pub fn new(name: &amp;'a str) -&gt; Vertex&lt;'a&gt; { Vertex { name } }}impl&lt;'a&gt; fmt::Display for Vertex&lt;'a&gt; { fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result { write!(f, \"{}\", self.name) }}#[derive(Debug)]struct Visit&lt;V&gt; { vertex: V, distance: usize,}impl&lt;V&gt; Eq for Visit&lt;V&gt; { }impl&lt;V&gt; PartialEq for Visit&lt;V&gt; { fn eq(&amp;self, other: &amp;Self) -&gt; bool { self.distance.eq(&amp;other.distance) }}impl&lt;V&gt; Ord for Visit&lt;V&gt; { fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering { other.distance.cmp(&amp;self.distance) }}impl&lt;V&gt; PartialOrd for Visit&lt;V&gt; { fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; { Some(other.distance.cmp(&amp;self.distance)) }} 필기노트 레퍼런스다익스트라 알고리즘 - 니무위키 23. 다익스트라(Dijkstra) 알고리즘 dijkstra-algorithm-in-rust","link":"/2020/04/22/dijkstra-algorithm/"},{"title":"Quick sort algorithm","text":"퀵 정렬 알고리즘퀵 정렬은 피벗을 기준으로 좌/우에 자신보다 큰/작은 값을 몰고, 문제를 조금씩 나눠가며 정렬을 하게 된다. 최악의 경우(항상 피벗이 모든 값 중 가장 작은 경우) O(n^2)를 가지는 상황이 나올 수 있지만, 확률적으로 그럴 일은 적기에 평균적으로 O(NlogN)의 시간복잡도를 가진다. 구현1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950fn main() { let mut myarr = MyArray::new(); myarr.values.extend_from_slice(&amp;[9, 8, 7, 6, 5, 2, 1, 2, 3, 1]); myarr.sort(); for value in &amp;myarr.values { print!(\"{} \", value); }}struct MyArray { values: Vec&lt;usize&gt;,}impl MyArray { pub fn new() -&gt; MyArray { MyArray { values: Vec::new() } } pub fn sort(&amp;mut self) { self.quick_sort(0, self.values.len() - 1); } fn quick_sort(&amp;mut self, left: usize, right: usize) { if left &lt; right { let pivot = self.partition(left, right); self.quick_sort(left, pivot - 1); self.quick_sort(pivot + 1, right); } } fn partition(&amp;mut self, left: usize, right: usize) -&gt; usize { let mut is_swap = false; let mut swap_pos = left; for x in left..right { if self.values[x] &lt;= self.values[right] { self.values.swap(swap_pos, x); swap_pos += 1; is_swap = true; } } if is_swap // 이미 정렬된 상태였을 경우는 제외 || (!is_swap &amp;&amp; (self.values[swap_pos] &gt; self.values[right])) // 피봇보다 값들이 모두 큰 경우 피봇을 가장 앞으로 이동. { self.values.swap(swap_pos, right); } swap_pos }} 필기노트 레퍼런스[자료구조 알고리즘] 퀵정렬(Quicksort)에 대해 알아보고 자바로 구현하기 퀵소트 / 퀵정렬 5분만에 이해하기 - Gunny","link":"/2020/04/24/quick-sort/"},{"title":"Merge sort algorithm","text":"합병 정렬(merge sort)합병 정렬은 분할정복 알고리즘이며 길이가 N인 리스트를 길이가 1인 리스트로 쪼개고 다시 쪼개진 각각의 리스트를 정렬하며 합병해 최종적으로 정렬된 리스트를 가지게 된다. 함수의 구조를 보면 알겠지만, 중앙 위치를 찾고 중앙 위치를 기준으로 좌측, 우측을 나눠 재귀 호출된다. 재귀 종료 조건은 start &lt; end의 조건에 맞지 않는다면 더 나뉠 수 없다고 판단하여 쪼개는 과정이 종료된다. 최종적으로 마지막 merge함수를 이용해 각 리스트를 합병한다. 중요한 점은 이때 임시버퍼를 사용해야 하는데, 만약 임시버퍼를 사용할 수 없는 조건이라면 합병 정렬은 사용할 수 없다. 구현12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849fn main() -&gt; Result&lt;(), std::io::Error&gt; { let mut arr = [1, 30, 2, 1, 3, 4, 1, 9, 10, 13, 11]; let mut tmp: [isize; 11] = [0; 11]; tmp.clone_from_slice(&amp;arr); MySortor::sort(&amp;mut arr, &amp;mut tmp); for v in &amp;arr { print!(\"{} \", v); } Ok(())}struct MySortor { }impl MySortor { pub fn sort(arr: &amp;mut [isize], tmp: &amp;mut [isize]) { MySortor::merge_sort(arr, tmp, 0, arr.len() - 1); } fn merge_sort(arr: &amp;mut [isize], tmp: &amp;mut [isize], start: usize, end: usize) { if start &lt; end { let mid = (start + end) / 2; MySortor::merge_sort(arr, tmp, start, mid); MySortor::merge_sort(arr, tmp, mid + 1, end); MySortor::merge(arr, tmp, start, mid, end); } } fn merge(arr: &amp;mut [isize], tmp: &amp;mut [isize], start: usize, mid: usize, end: usize) { let mut p1 = start; let mut p2 = mid + 1; let mut store_index = start; tmp.clone_from_slice(arr); while p1 &lt;= mid &amp;&amp; p2 &lt;= end { if tmp[p1] &lt;= tmp[p2] { arr[store_index] = tmp[p1]; p1 += 1; } else { arr[store_index] = tmp[p2]; p2 += 1; } store_index += 1; } let e = mid as isize - p1 as isize; for i in 0..=e { arr[store_index + i as usize] = tmp[p1 + i as usize]; } }} 필기노트 레퍼런스[알고리즘] 합병 정렬(merge sort)이란 [자료구조 알고리즘] 병합정렬(Merge Sort) 구현하기","link":"/2020/04/27/merge-sort/"},{"title":"64bit 멀티코어 OS 원리와 구조 - Day 1","text":"이 글은 ‘64비트 멀티코어 OS 원리와 구조 - 한승훈 저자’을 공부하며 정리한 내용을 작성했습니다. 세상에서 가장 간단한 BootLoader부트 로더를 정상적으로 불러오기 위해서는 한가지 규칙이 있다. 먼저 부트 섹터 512Byte의 마지막 2Byte는 반드시 0x55, 0xAA를 가져야 한다. 아래는 세상에서 가장 간단한 부트로더를 작성한 소스 코드이다. 12345678[ORG 0x00][BITS 16]SECTION .textjmp $times 510 - ($ - $$) db 0x00db 0x55db 0xAA 위 코드에서 [ORG 0x00]은 0x00 메모리 주소에서 시작한다는 의미이며, [BITS 16]은 아래 코드는 16bit라고 알려준다. SECTION .text은 .text 섹션의 시작을 의미하고 jmp $은 현재 위치에서 무한 Loop을 하며 대기하게 한다. 여기까지 총 몇 Byte가 작성된 지 소스 코드로는 확인이 어렵기에 510byte (512byte에서 마지막 0x55, 0xAA 2byte를 뺀 숫자)만큼 채우기 위해서 times 510 - ($ - $$) db 0x00이라고 표현한다. 이 의미는 $(현재 주소)이에서 $$(섹션의 주소)를 뺀 값, 다시 말해 총 생성된 opcode 크기를 뺀 나머지를 0x00으로 채우겠다는 의미이다. 이후 0x55, 0xAA를 채우면 정확히 512byte 크기의 바이너리 파일이 생성되게 된다. 화면 버퍼 제어어릴 적 컴퓨터를 키면 깜빡이는 커서와 함께 뜻 모를 영어들이 주룩주룩 나오는 걸 본 기억이 있다. 현재 작성된 Boot Loader에 위와 같은 기능을 구현하기 위해서는 비디오 메모리에 형식에 맞춰 데이터를 넣어주는 거로 구현할 수 있다. 그러기 위해선 비디오 메모리의 시작 주소 0xB8000에 문자 1 Byte, 속성 1 Byte 총 2 Byte인 형식에 맞춰 가로 80, 세로 25자 총 4000 Byte에 작성하게 된다. 12345678... 생략 ...SECTION .textmov ax, 0xb800mov ds, axmov byte[0x00], 'J'mov byte[0x01], 0x4Ajmp $... 생략 ... 이렇게 작성하고 QEMU를 실행하면 첫 글자가 빨간 배경의 J가 보이게 된다. 세그먼트 초기화BIOS가 Boot Loader를 디스크에서 메모리(메모리의 0x7c00에 복사한다.)에 복사를 하게 되고 Boot Loader가 코드를 수행하기 전 세그먼트를 초기화하지 않으면 BIOS에서 사용했던 세그먼트 값으로 인해 예기치 못한 오류가 생길 수 있다. 그렇기 때문에 Boot Loader에선 먼저 세그먼트를 초기화 해주는 게 중요하다. 이 책에서는 CS(코드 세그먼트), DS(데이터 세그먼트), ES(비디오 메모리를 위해 사용될 세그먼트)를 각각 0x07c0, 0x07c0, 0xb800으로 초기화한다. 여기서 CS는 mov 명령어로 수정할 수 없기 때문에 jmp 명령어를 이용하는데 코드는 다음과 같다. 123456jmp 0x07c0:STARTSTART: mov ax, 0x07c0 mov ds, ax mov ax, 0xb800 mov es, ax 화면 정리 및 메세지 출력우리는 지금까지 Boot loader를 만들고, 세그먼트를 초기화했다. 이제 미리 출력된 메시지를 지우고, 우리의 메시지를 출력하도록 해보자. 먼저 화면을 정리하기 위해서는 기존 비디오 메모리에 있던 내용을 지워줄 필요가 있다. 12345i = 0while i&lt;80*25*2 vdomem[i]=0 vdomem[i+1]=0x0A i+=2 의사 코드로 표현하면 위 코드처럼 표현할 수 있다. 이를 어셈블리어로 움기면 다음과 같다. 1234567 mov si, 0.SCREENCLEARLOOP: mov byte[es:si], 0 mov byte[es:si+1], 0x0a add si, 2 cmp si, 80*25*2 jl .SCREENCLEARLOOP 다음으로 문자열을 출력하는 코드를 작성한다. 123456789101112131415 mov si, 0 mov di, 0.MESSAGELOOP: mov cl, byte[si+MESSAGE1] cmp cl, 0 je .MESSAGED mov byte [es:di], cl add si, 1 add di, 2 jmp .MESSAGELOOP.MESSAGED: MESSAGE1: db 'JUNOS BootLoader...!', 0 최종 BootLoader1234567891011121314151617181920212223242526272829303132333435363738[ORG 0x00][BITS 16]SECTION .textjmp 0x07c0:STARTSTART: mov ax, 0x07c0 mov ds, ax mov ax, 0xb800 mov es, ax mov si, 0.SCREENCLEARLOOP: mov byte[es:si], 0 mov byte[es:si+1], 0x0a add si, 2 cmp si, 80*25*2 jl .SCREENCLEARLOOP mov si, 0 mov di, 0.MESSAGELOOP: mov cl, byte[si+MESSAGE1] cmp cl, 0 je .MESSAGED mov byte [es:di], cl add si, 1 add di, 2 jmp .MESSAGELOOP.MESSAGED: jmp $ MESSAGE1: db 'JUNOS BootLoader...!', 0times 510 - ($ - $$) db 0x00db 0x55db 0xAA","link":"/2020/04/28/multicoreos64-day1/"},{"title":"64bit 멀티코어 OS 원리와 구조 - Day 2","text":"이 글은 ‘64비트 멀티코어 OS 원리와 구조 - 한승훈 저자’을 공부하며 정리한 내용을 작성했습니다. 이미지 로딩 구현책에서 구현하게 될 OS는 부트 로더, 보호 모드 커널, IA-32e 모드 커널로 구성되고 섹터 단위로 정렬되 하나의 부팅 이미지로 만들어지며 두 번째 섹터부터 읽어 메모리에 복사하면 이미지 로딩이 끝나게 된다. 책에서 구현하는 OS는 메모리 0x10000번지에 복사하게 되며, 이 주소는 정해진게 아니라 부트 로더 이후에 바로 복사해도 되지만, 책의 뒷장에서 0x10000 이하 번지를 다른 용도로 사용하기 위해서 비워둔다. x86 프로세서는 스택과 관련된 레지스터가 3개 있는데 SS, SP, BP가 있다. 이때 SS를 어떻게 설정하느냐에 따라서 스택의 크기가 달라지는데 예를 들어 SS를 0x0000으로 설정한다면 0x00000~0x0FFFF SS를 0x1000으로 설정하면 0x010000~0x01FFFF까지 된다. 이렇게 SS를 통해서 스택의 범위를 지정할 순 있지만, 스택의 크기는 정하지 못하는데 32bit의 스택 한 칸의 크기는 4byte이다. 리얼 모드에서 보호 모드로의 전환보호 모드로 전환하는 단계는 크게 6단계라고 할 수 있다. 2단계는 보호 모드 전환을 위한 자료구조 생성, 나머지 4단계는 생성된 자료구조를 프로세서에 설정을 한다. 2단계에서 생성할 필수 자료구조는 세그먼트 디스크립터와 GDT이다. 이 두 자료구조는 전환 즉시 프로세서에 의해 참조되므로 미리 생성해야 한다. 세그먼트 디스크립터 생성세그먼트 디스크립터는 세그먼테이션 기법(메모리 관리 기법)에서 세그먼트의 정보를 나타내는 자료구조이다. 여기서 세그먼트는 메모리 공간을 임의의 크기로 나눈 영역을 의미한다. 세그먼트 디스크립터는 크게 코드 세그먼트, 데이터 세그먼트 디스크립터로 나뉜다. 코드 세그먼트 : 실행가능한 코드가 포함된 세그먼트에 대한 정보 CS 세그먼트 셀렉터에 사용 데이터 세그먼트 : 데이터가 포함된 세그먼트에 대한 정보를 나타냄, CS를 제외한 나머지 세그먼트에 사용할 수 있음. 세그먼트 디스크립트 구조는 책의 사진이 더욱 이해하기 쉬워 연관된 필드를 작성하는 것으로 대체합니다. 세그먼트 디스크립터 구조 S, 타입 : S 필드로 세그먼트 디스크립트임을 표시하고, 타입 필드로 읽기/쓰기, 실행/읽기 으로 설정한다. 크기, G : 크기 필드는 총 20비트이며 최댓값은 1MB지만, 전체 4GB를 접근하기엔 무리가 있다. 따라서 G 필드를 활용해 1MB에 4KB가 곱해진 4GB에 접근할 수 있도록 한다. D/B, L, 권한 : 기본 오퍼랜드 크기, 권한 설정 P, AVL : 기타 등등 ^^;; GDTGDT(Global Descriptor Table)은 연속된 디스크립터의 집합이다. 앞서 코드 세그먼트 디스크립터와 데이터 세그먼트 디스크립터를 어셈블리어로 생성하였는데 이를 연속된 영역이 GDT이다. 다만 한 가지 제약이 있는데 가장 앞부분에 NULL 디스크립터를 추가해야한다는 점이다. NULL 디스크립터는 프로세서에 의해 예약된 모든 필드가 NULL(=0)인 디스크립터이다. 모든 값이 NULL이기에 일반적으론 참조되지 않는다. GDT는 디스크립터의 집합이므로 디스크립터가 필요한 프로세서에게 GDT의 시작 주소와 크기를 알려줘야 한다. 따라서 GDT의 시작주소, 크기 정보를 가지고 있는 자료구조(GDTR)가 필요하게 된다. 32bit의 기준 주소 필드는 데이터 세그먼트의 기준 주소와 상관없이 0번째 주소를 기준으로 하는 선형 주소이다. 따라서 GDT의 시작 어드레스를 실제 메모리 공간상의 주소로 변환할 필요가 없다. 보호 모드로 전환보호 모드로 전환하려면 GDTR 레지스터 설정, CR0 컨트롤 레지스터 설정, jmp 명령 수행 3단계만 수행하면 된다. 먼저 프로세서에 GDT 정보를 설정하려면 lgdt(load GDT) 명령어를 사용한다. lgdt는 앞서 어셈블리로 작성했던 GDT의 시작 주소, GDT 크기를 오퍼랜드로 받는다. 단 한 줄로 GDT가 로드된 것이다. 다음은, CR0 컨트롤 레지스터를 설정하는데 CR0 컨트롤 레지스터는 보호 모드 전환에 관련된 필드 외에 캐시, 페이징, 실수 연산 장치 등과 관련된 필드가 포함되어 있다. CR0 컨트롤 레지스터 또한 세그먼테이션 기능외에는 사용하지 않기에 책을 통해 확인하자. 앞서 리얼 모드에서 세그먼트 레지스터(aka. 세그먼트 셀렉터)는 세그먼트의 시작 주소를 저장하는 레지스터였다. 보호 모드의 세그먼트(세그먼트 레지스터 아님)는 리얼 모드와 달리 다양한 정보를 포함하고 있어 세그먼트 정보는 디스크립터에 저장하고, 세그먼트 레지스터(aka. 세그먼트 셀렉터)는 그 디스크립터를 지시하는 용도로 사용한다. [세그먼트 레지스터] -&gt; [디스크립터(세그먼트 정보가 포함되어 있음.)]와 같은 모양을 가지고 있다고 할 수 있다. 보호 모드 또한 세그먼트 셀렉터에 어드레스를 설정하여 GDT 내의 디스크립터를 참조한다. 다만, 세그먼트의 기준 주소 대신 GDT 내의 디스크립터의 주소를 사용한다. 예를 들어 NULL 디스크립터 다음의 커널 코드 세그먼트 디스크립터를 사용하고 싶다면, 디스크립터의 크기가 8byte임을 고려해 세그먼트 셀렉터에 8을 넣으면 된다. 요약하자면 주소가 아닌 오프셋으로 접근한다. EntryPoint.s 파일의 내용은 책 또는 공식 Github를 참고!","link":"/2020/04/29/multicoreos64-day2/"},{"title":"Arch linux 설치하기","text":"이 글은 인터넷에 작성된 Arch linux를 설치하는 방법을 개인적으로 정리한 글입니다. 글의 대부분의 내용은 아래 ‘레퍼런스’에 출처가 작성되어있으니 자세한 내용을 원본 글에서 참조하시는걸 추천해 드립니다. Arch Linux를 설치하며 가상 먼저 하는 것은 당연히 arch linux의 설치 ISO 파일을 구하는 것부터 시작된다. 먼저 PC에서 설치하는 것보단 Virtual Box 같은 가상 PC에서 설치하기 위해서 USB에 굽는 과정을 생략했다. 먼저 한국 미러링 서버에서 받기 원한다면 이곳에서 다운로드받을 수 있다. 다른 나라를 이용하고 싶다면 이곳에서 원하는 나라의 미러링 서버를 확인할 수 있다. 레퍼런스How to Install Arch Linux on VirtualBox 아치 리눅스 설치 가이드","link":"/2020/04/30/archlinux-install/"},{"title":"64bit 멀티코어 OS 원리와 구조 - Day 3","text":"이 글은 ‘64비트 멀티코어 OS 원리와 구조 - 한승훈 저자’을 공부하며 정리한 내용을 작성했습니다. C언어로 커널을 작성하자실행 가능한 C 코드 커널 생성 방법빌드 조건과 제약 사항지금까지 작성된 코드는 단일 파일로 NASM 컴파일을 통해 바이너리 파일 형태로 만들어졌다. 직전 EntryPoint.s 코드도 단일 파일로 작성되었고, 512byte로 정렬되어 이미지 파일에 결합(Disk.img 파일에 포함)하는 구조다. 이 장에서는 보호 모드 EntryPoint(이하, 엔트리포인트)의 뒷부분에 C언어로 작성한 커널을 연결하고, C 커널의 시작 부분으로 이동하는 것이 목표이다. 먼저, 엔트리 포인트가 C언어 코드를 실행하려면 3가지 제약 조건을 만족해야 한다. C 라이브러리를 사용하지 않게 빌드해야 한다. 부팅된 후 보호 모드 커널이 실행되면 C 라이브러리가 없음으로 라이브러리에 포함된 함수(printf, scanf, …)를 호출할 수 없다. 0x10200 위치에서 실행하게끔 빌드해야 한다. 0x10000의 위치에는 이전 장(6장)에서 작성한 EntryPoint.s가 512byte(1 섹터) 만큼 위치하기 때문에 0x1000 + 0x200(512byte) 뒤인 0x10200에 위치해야 한다. 코드나 데이터 외에 기타 정보를 포함하지 않은 순수한 바이너리 파일 형태야 한다. GCC를 통해 컴파일하면 ELF 또는 PE 와 같은 OS에 의존적인 실행 파일 포맷으로 생성된다. 이런 파일을 포맷이 포함되게 되면 이 정보를 처리하기 위한 부가적인 복잡한 코드를 생성해야 하기 때문에 순수한 바이너리 파일을 생성해야 한다. 1&gt; x86_64-pc-linux-gcc.exe -c -m32 -ffreestanding Main.c 라이브러리를 사용하지 않고 홀로 사용하기 위해서 GCC 컴파일러는 -ffreestanding옵션을 지원하고 있으며, -c과 함께 라이브러리를 사용하지 않는 오브젝트 파일을 생성할 수 있다. 섹션 배치와 링커 스크립트, 라이브러리를 사용하지 않는 링크 이 부분은 불필요한 섹션을 제거(또는 이동)하여 섹션을 재배치하고 보호 모드 엔트리포인트에서 커널로 이동하는 설정을 다루고 있습니다. 따라서 코드는 책의 내용을 참고하시는게 좋습니다. 작성하는 커널의 위치는 0x10000의 보호 모드 엔트리포인트에서 1섹터(512byte)만큼 떨어진 0x10200에 위치하도록 한다. 1&gt; x86_64-pc-linux-ld.exe -Ttext 0x10200 Main.o -o Main.elf 그리고 커널의 엔트리 포인터를 Main함수로 만들기 위해서 다음과 같이 엔트리 포인터를 설정한다. 1&gt; x86_64-pc-linux-ld.exe -e Main Main.o -o Main.elf","link":"/2020/05/01/multicoreos64-day3/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"rust-lang","slug":"rust-lang","link":"/tags/rust-lang/"},{"name":"os","slug":"os","link":"/tags/os/"},{"name":"kernel","slug":"kernel","link":"/tags/kernel/"},{"name":"bootloader","slug":"bootloader","link":"/tags/bootloader/"},{"name":"archlinux","slug":"archlinux","link":"/tags/archlinux/"},{"name":"linux","slug":"linux","link":"/tags/linux/"}],"categories":[{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","link":"/categories/Programming/Algorithm/"},{"name":"CE","slug":"CE","link":"/categories/CE/"},{"name":"OS","slug":"CE/OS","link":"/categories/CE/OS/"},{"name":"Linux","slug":"CE/Linux","link":"/categories/CE/Linux/"}]}